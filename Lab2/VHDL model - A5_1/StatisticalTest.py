from __future__ import division
import scipy.special as spc
import math
import numpy


def checker(p_val):
    epsilon = 0.01
    if p_val > epsilon:
        print("Sequence is Random")
    else:
        print("Sequence is NOT Random")

def count_zeros_and_ones(bin_data):
    ones, zeros = 0, 0
    # If the char is 0 minus 1, else add 1
    for char in bin_data:
        if char == '0':
            zeros += 1
        else:
            ones += 1
    print"Count 1 =", ones, "Count 0 =", zeros


def monobit(bin_data):
    count = 0
    # If the char is 0 minus 1, else add 1
    for char in bin_data:
        if char == '0':
            count -= 1
        else:
            count += 1
    # Calculate the p value
    sobs = abs(count) / math.sqrt(len(bin_data))
    p_val = spc.erfc(math.fabs(sobs) / math.sqrt(2))
    return p_val

def block_frequency(bin_data, block_size=128):
    # Work out the number of blocks, discard the remainder
    num_blocks = math.floor(len(bin_data) / block_size)
    block_start, block_end = 0, block_size
    # Keep track of the proportion of ones per block
    proportion_sum = 0.0
    for i in range(int(num_blocks)):
        # Slice the binary string into a block
        block_data = bin_data[block_start:block_end]
        # Keep track of the number of ones
        ones_count = 0
        for char in block_data:
            if char == '1':
                ones_count += 1
        pi = ones_count / block_size
        proportion_sum += pow(pi - 0.5, 2.0)
        # Update the slice locations
        block_start += block_size
        block_end += block_size
    # Calculate the p-value
    chi_squared = 4.0 * block_size * proportion_sum
    p_val = spc.gammaincc(num_blocks / 2, chi_squared / 2)
    return p_val

def runs(bin_data):
    ones_count, n = 0, len(bin_data)
    for char in bin_data:
        if char == '1':
            ones_count += 1
    p, vobs = float(ones_count / n), 1
    tau = 2 / math.sqrt(len(bin_data))
    if abs(p - 0.5) >= tau:
        return 0.0
    else:
        for i in range(1, n):
            if bin_data[i] != bin_data[i - 1]:
                vobs += 1

        num = abs(vobs - 2.0 * n * p * (1.0 - p))
        den = 2.0 * math.sqrt(2.0 * n) * p * (1.0 - p)
        p_val = spc.erfc(float(num / den))
        return p_val

def longest_runs(bin_data):
    if len(bin_data) < 128:
        print("\t", "Not enough data to run test!")
        return -1.0
    elif len(bin_data) < 6272:
        k, m = 3, 8
        v_values = [1, 2, 3, 4]
        pik_values = [0.21484375, 0.3671875, 0.23046875, 0.1875]
    elif len(bin_data) < 75000:
        k, m = 5, 128
        v_values = [4, 5, 6, 7, 8, 9]
        pik_values = [0.1174035788, 0.242955959, 0.249363483, 0.17517706, 0.102701071, 0.112398847]
    else:
        k, m = 6, 10000
        v_values = [10, 11, 12, 13, 14, 15, 16]
        pik_values = [0.0882, 0.2092, 0.2483, 0.1933, 0.1208, 0.0675, 0.0727]

    # Work out the number of blocks, discard the remainder
    num_blocks = math.floor(len(bin_data) / m)
    frequencies = numpy.zeros(k + 1)
    block_start, block_end = 0, m
    for i in range(int(num_blocks)):
        # Slice the binary string into a block
        block_data = bin_data[block_start:block_end]
        # Keep track of the number of ones
        max_run_count, run_count = 0, 0
        for j in range(0, m):
            if block_data[j] == '1':
                run_count += 1
                max_run_count = max(max_run_count, run_count)
            else:
                max_run_count = max(max_run_count, run_count)
                run_count = 0
        max_run_count = max(max_run_count, run_count)
        if max_run_count < v_values[0]:
            frequencies[0] += 1
        for j in range(k):
            if max_run_count == v_values[j]:
                frequencies[j] += 1
        if max_run_count > v_values[k - 1]:
            frequencies[k] += 1
        block_start += m
        block_end += m
    chi_squared = 0
    for i in range(len(frequencies)):
        chi_squared += (pow(frequencies[i] - (num_blocks * pik_values[i]), 2.0)) / (num_blocks * pik_values[i])
    p_val = spc.gammaincc(float(k / 2), float(chi_squared / 2))
    return p_val

def readKeystream(fname):

    with open(fname) as f:
        content = f.readlines()
    # Remove whitespace characters like `\n` at the end of each line
    content = [x.strip('\n') for x in content]
    a= ''.join(content)
    return a

if __name__ == '__main__':
    fname = 'C:\Users\usuario\Master\output_results.txt'
    # RND is generated by implementatiion of A5/1 using ghdl model.
    RND = readKeystream(fname)
    print("======================================================================")
    print("Assignment #4 from List #2 - Embedded Security Systems")
    print("Statistical Tests from NIST standard")
    print("======================================================================")
    print("1) Counting Zeros and Ones:")
    count_zeros_and_ones(RND)
    print("2) Counting the proportion of zeros and ones:")
    checker(monobit(RND))
    print('p_val='), monobit(RND)
    print("3) Counting the frequency of ones in a block of 128 bits:")
    checker(block_frequency(RND))
    print('p_val='), block_frequency(RND)
    print("4) Counting runs of ones and zeros:")
    checker(runs(RND))
    print('p_val='), runs(RND)
    print("5) Counting longest runs of ones in a block of 128 bits:")
    checker(longest_runs(RND))
    print('p_val='), longest_runs(RND)